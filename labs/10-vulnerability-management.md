# Vulnerability Management

## Indice

- [Vulnerability Management with DefectDojo (Mandatory)](#vulnerability-management-with-defectdojo)
- [Automated Results Upload in GitLab (Mandatory)](#automated-results-upload-in-gitlab)
- [Automated Results Upload in GitHub Actions (Optional)](#automated-results-upload-in-gitHub-actions)

## Vulnerability Management with DefectDojo

### Learn how to use Defect Dojo to manage vulnerabilities

In this scenario, you will learn how to use **Defect Dojo** to manage vulnerabilities in a **DevSecOps** environment.

You will run bandit scan on a repository and then upload the results to Defect Dojo.

To achieve the above objectives, you will need to do the following.

1. Clone/download the source code
2. Install bandit tool
3. Run the SAST scan on the source code
4. Upload the result to DefectDojo with custom script

> Once you click the **Start the Exercise** button, you will need to **wait a minute** for the DefectDojo machine to start.

> Remember!
>
>Except for DevSecOps-Box, every other machine **closes after two hours**, even if you are in the middle of the exercise
>
>After two hours, in case of a **404**, you need to refresh the exercise page and click on **Start the Exercise** button to continue working

### Download the source code

We will do all the exercises locally first in DevSecOps-Box, so let’s start the exercise.

First, we need to download the source code of the project from our git repository.

```bash
git clone https://gitlab.practical-devsecops.training/pdso/django.nv webapp
```

Let’s cd into the application so we can scan the app.

```bash
cd webapp
```

We are now in the **webapp** directory.

Let’s move to the **next step**.

### Install SAST Tool

Let’s install the bandit scanner on the system to perform static analysis.

```bash
pip3 install bandit
```

```bash
Collecting bandit
  Downloading bandit-1.7.0-py3-none-any.whl (115 kB)
     |████████████████████████████████| 115 kB 16.2 MB/s 
Collecting stevedore>=1.20.0
  Downloading stevedore-3.3.0-py3-none-any.whl (49 kB)
     |████████████████████████████████| 49 kB 15.1 MB/s 
Collecting PyYAML>=5.3.1
  Downloading PyYAML-5.4.1-cp36-cp36m-manylinux1_x86_64.whl (640 kB)
     |████████████████████████████████| 640 kB 62.4 MB/s 
Collecting six>=1.10.0
  Downloading six-1.16.0-py2.py3-none-any.whl (11 kB)
Collecting GitPython>=1.0.1
  Downloading GitPython-3.1.18-py3-none-any.whl (170 kB)
     |████████████████████████████████| 170 kB 66.6 MB/s 
Requirement already satisfied: typing-extensions>=3.7.4.0 in /usr/local/lib/python3.6/dist-packages (from GitPython>=1.0.1->bandit) (3.10.0.0)
Collecting gitdb<5,>=4.0.1
  Downloading gitdb-4.0.7-py3-none-any.whl (63 kB)
     |████████████████████████████████| 63 kB 6.0 MB/s 
Collecting smmap<5,>=3.0.1
  Downloading smmap-4.0.0-py2.py3-none-any.whl (24 kB)
Requirement already satisfied: importlib-metadata>=1.7.0 in /usr/local/lib/python3.6/dist-packages (from stevedore>=1.20.0->bandit) (4.6.1)
Collecting pbr!=2.1.0,>=2.0.0
  Downloading pbr-5.6.0-py2.py3-none-any.whl (111 kB)
     |████████████████████████████████| 111 kB 82.5 MB/s 
Requirement already satisfied: zipp>=0.5 in /usr/local/lib/python3.6/dist-packages (from importlib-metadata>=1.7.0->stevedore>=1.20.0->bandit) (3.5.0)
Installing collected packages: smmap, pbr, gitdb, stevedore, six, PyYAML, GitPython, bandit
Successfully installed GitPython-3.1.18 PyYAML-5.4.1 bandit-1.7.0 gitdb-4.0.7 pbr-5.6.0 six-1.16.0 smmap-4.0.0 stevedore-3.3.0
WARNING: Running pip as the 'root' user can result in broken permissions and conflicting behaviour with the system package manager. It is recommended to use a virtual environment instead: https://pip.pypa.io/warnings/venv
```

We have successfully installed the bandit scanner.

Let’s move to the **next step** to run the scanner against a repository.

### Run the scanner

As we have learned in the **DevSecOps Gospel**, we would like to store the tool results in a **JSON** file. We are using the tee command here to show the output and store it in a file simultaneously.

```bash
bandit -r . -f json | tee bandit-output.json
```

Bandit ran successfully, and it found three security issues.

1. One high severity issue
2. One medium severity issue
3. One low severity issue

Let’s upload this file to Defect Dojo in the next step.

Let’s move to the **next step**.

### Upload the results to Defect Dojo

Let’s explore the Defect Dojo application now.

Defect Dojo provides an API to upload the scan results, and this is an excellent feature for uploading scan results during CI/CD process. We have created a simple upload script for you, and you can download this script using the following command.

```bash
curl https://gitlab.practical-devsecops.training/-/snippets/3/raw -o upload-results.py
```

Let’s explore what options it provides us.

```bash
python3 upload-results.py --help
```

```
Traceback (most recent call last):
  File "upload-results.py", line 7, in <module>
    import requests
ModuleNotFoundError: No module named 'requests'
```

It looks like the module **requests** is not available. Lets install it and upload the results.

```bash
pip3 install requests
```

Now, we can try re-running the command and see if it works.

```bash
python3 upload-results.py --help
```

```bash
usage: upload-results.py [-h] --host HOST --api_key API_KEY --engagement_id
                         ENGAGEMENT_ID --result_file RESULT_FILE --scanner
                         SCANNER --product_id PRODUCT_ID --lead_id LEAD_ID
                         [--build_id BUILD_ID]

CI/CD integration for DefectDojo

optional arguments:
  -h, --help            show this help message and exit
  --host HOST           DefectDojo Hostname
  --api_key API_KEY     API v2 Key
  --engagement_id ENGAGEMENT_ID
                        Engagement ID
  --result_file RESULT_FILE
                        Scanner file
  --scanner SCANNER     Type of scanner
  --product_id PRODUCT_ID
                        DefectDojo Product ID
  --lead_id LEAD_ID     ID of the user conducting the testing
  --environment ENVIRONMENT
                        Environment name
  --build_id BUILD_ID   Reference to external build id
```

We need to provide the following inputs for this script to work.

Name	Value
**HOST**	https://dojo-xIKciVAk.lab.practical-devsecops.training
**USERNAME**	root
**API_KEY**	Find it at https://dojo-xIKciVAk.lab.practical-devsecops.training/api/key-v2
**ENGAGEMENT_ID**	ID of the engagement, here its 1
**PRODUCT_ID**	ID of product, here its 1
**LEAD_ID**	ID of the user conducting the testing
**ENVIRONMENT**:	Environment name
**SCANNER**	Name of the scanner, this is case sensitive e.g., ZAP Scan, Bandit Scan, etc
**RESULT_FILE**	The path to the tool’s output

You need to first log into the dojo website using the following credentials to fetch the API Key.

Machine Details	
**Dojo URL**	dojo-xIKciVAk.lab.practical-devsecops.training/api/key-v2
**Username**	root
**Password**	pdso-training

You can copy the **API_KEY** from the DefectDojo app and replace **INSERT_API_KEY_HERE** with the API_KEY in the below command.

```bash
export API_KEY=INSERT_API_KEY_HERE
# export API_KEY=
```

You can also use the following command to get a token programmatically.

```bash
export API_KEY=$(curl -s -XPOST -H 'content-type: application/json' https://dojo-xIKciVAk.lab.practical-devsecops.training/api/v2/api-token-auth/ -d '{"username": "root", "password": "pdso-training"}' | jq -r '.token' )
```

> Make sure the API_KEY shows an output when executing echo $API_KEY command. If not, you need to wait until the DefectDojo is ready.

We can now upload the bandit’s scan output (**bandit-output.json**) to Defect Dojo.

```bash
python3 upload-results.py --host dojo-xIKciVAk.lab.practical-devsecops.training --api_key $API_KEY --engagement_id 1 --product_id 1 --lead_id 1 --environment "Production" --result_file bandit-output.json --scanner "Bandit Scan"
```

```bash
{'Authorization': 'Token 6af287e26400d905720156c5e0965ea236dabe35'}
{'minimum_severity': 'Low', 'scan_date': '2021-02-16', 'verified': False, 'active': False, 'engagement': '1', 'lead': '1', 'scan_type': 'Bandit Scan', 'environment': 'Production'}
Successfully uploaded the results to Defect Dojo
```

Visit the https://dojo-xIKciVAk.lab.practical-devsecops.training/engagement/1 to see the uploaded issues.

Let’s move to the **next step**.

### Challenge: Upload ZAP results to Defect Dojo manually

In this exercise, you will use the upload-results.py script to upload the ZAP Scan results to the Defect Dojo.

1. Scan the production machine https://prod-xIKciVAk.lab.practical-devsecops.training with the help of the ZAP docker image
2. Store the ZAP scan results in a file and upload the results to Defect Dojo

```bash
docker pull owasp/zap2docker-stable:2.10.0
export PROD_URL="https://prod-xIKciVAk.lab.practical-devsecops.training"
# https://defectdojo.github.io/django-DefectDojo/integrations/import/#zed-attack-proxy
docker run --user root --rm -v $(pwd):/zap/wrk:rw -w /zap owasp/zap2docker-stable:2.10.0 zap-baseline.py -t ${PROD_URL} -x zap-output.xml
python3 upload-results.py --host dojo-xIKciVAk.lab.practical-devsecops.training --api_key $API_KEY --engagement_id 1 --product_id 1 --lead_id 1 --environment "Production" --result_file zap-output.xml --scanner "ZAP Scan"
```

```
cat zap-output.json
{
  "@version": "2.10.0",
  "@generated": "Tue, 19 Oct 2021 09:36:43",
  "site": [
    {
      "@name": "https://prod-xIKciVAk.lab.practical-devsecops.training",
      "@host": "prod-xIKciVAk.lab.practical-devsecops.training",
      "@port": "443",
      "@ssl": "true",
      "alerts": [
        {
          "pluginid": "10038",
          "alertRef": "10038",
          "alert": "Content Security Policy (CSP) Header Not Set",
          "name": "Content Security Policy (CSP) Header Not Set",
          "riskcode": "2",
          "confidence": "3",
          "riskdesc": "Medium (High)",
          "desc": "<p>Content Security Policy (CSP) is an added layer of security that helps to detect and mitigate certain types of attacks, including Cross Site Scripting (XSS) and data injection attacks. These attacks are used for everything from data theft to site defacement or distribution of malware. CSP provides a set of standard HTTP headers that allow website owners to declare approved sources of content that browsers should be allowed to load on that page — covered types are JavaScript, CSS, HTML frames, fonts, images and embeddable objects such as Java applets, ActiveX, audio and video files.<\/p>",
          "instances": [
            {
              "uri": "https://prod-xIKciVAk.lab.practical-devsecops.training/robots.txt",
              "method": "GET"
            },
            {
              "uri": "https://prod-xIKciVAk.lab.practical-devsecops.training/sitemap.xml",
              "method": "GET"
            },
            {
              "uri": "https://prod-xIKciVAk.lab.practical-devsecops.training",
              "method": "GET"
            }
          ],
          "count": "3",
          "solution": "<p>Ensure that your web server, application server, load balancer, etc. is configured to set the Content-Security-Policy header, to achieve optimal browser support: \"Content-Security-Policy\" for Chrome 25+, Firefox 23+ and Safari 7+, \"X-Content-Security-Policy\" for Firefox 4.0+ and Internet Explorer 10+, and \"X-WebKit-CSP\" for Chrome 14+ and Safari 6+.<\/p>",
          "reference": "<p>https://developer.mozilla.org/en-US/docs/Web/Security/CSP/Introducing_Content_Security_Policy<\/p><p>https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html<\/p><p>http://www.w3.org/TR/CSP/<\/p><p>http://w3c.github.io/webappsec/specs/content-security-policy/csp-specification.dev.html<\/p><p>http://www.html5rocks.com/en/tutorials/security/content-security-policy/<\/p><p>http://caniuse.com/#feat=contentsecuritypolicy<\/p><p>http://content-security-policy.com/<\/p>",
          "cweid": "693",
          "wascid": "15",
          "sourceid": "3"
        },
        {
          "pluginid": "10040",
          "alertRef": "10040",
          "alert": "Secure Pages Include Mixed Content (Including Scripts)",
          "name": "Secure Pages Include Mixed Content (Including Scripts)",
          "riskcode": "2",
          "confidence": "2",
          "riskdesc": "Medium (Medium)",
          "desc": "<p>The page includes mixed content, that is content accessed via HTTP instead of HTTPS.<\/p>",
          "instances": [
            {
              "uri": "https://prod-xIKciVAk.lab.practical-devsecops.training",
              "method": "GET",
              "evidence": "http://html5shim.googlecode.com/svn/trunk/html5.js"
            }
          ],
          "count": "1",
          "solution": "<p>A page that is available over SSL/TLS must be comprised completely of content which is transmitted over SSL/TLS.<\/p><p>The page must not contain any content that is transmitted over unencrypted HTTP.<\/p><p> This includes content from third party sites.<\/p>",
          "otherinfo": "<p>tag=script src=http://html5shim.googlecode.com/svn/trunk/html5.js<\/p><p><\/p>",
          "reference": "<p>https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html<\/p>",
          "cweid": "311",
          "wascid": "4",
          "sourceid": "3"
        },
        {
          "pluginid": "10036",
          "alertRef": "10036",
          "alert": "Server Leaks Version Information via \"Server\" HTTP Response Header Field",
          "name": "Server Leaks Version Information via \"Server\" HTTP Response Header Field",
          "riskcode": "1",
          "confidence": "3",
          "riskdesc": "Low (High)",
          "desc": "<p>The web/application server is leaking version information via the \"Server\" HTTP response header. Access to such information may facilitate attackers identifying other vulnerabilities your web/application server is subject to.<\/p>",
          "instances": [
            {
              "uri": "https://prod-xIKciVAk.lab.practical-devsecops.training",
              "method": "GET",
              "evidence": "nginx/1.14.0 (Ubuntu)"
            },
            {
              "uri": "https://prod-xIKciVAk.lab.practical-devsecops.training/robots.txt",
              "method": "GET",
              "evidence": "nginx/1.14.0 (Ubuntu)"
            },
            {
              "uri": "https://prod-xIKciVAk.lab.practical-devsecops.training/sitemap.xml",
              "method": "GET",
              "evidence": "nginx/1.14.0 (Ubuntu)"
            }
          ],
          "count": "3",
          "solution": "<p>Ensure that your web server, application server, load balancer, etc. is configured to suppress the \"Server\" header or provide generic details.<\/p>",
          "reference": "<p>http://httpd.apache.org/docs/current/mod/core.html#servertokens<\/p><p>http://msdn.microsoft.com/en-us/library/ff648552.aspx#ht_urlscan_007<\/p><p>http://blogs.msdn.com/b/varunm/archive/2013/04/23/remove-unwanted-http-response-headers.aspx<\/p><p>http://www.troyhunt.com/2012/02/shhh-dont-let-your-response-headers.html<\/p>",
          "cweid": "200",
          "wascid": "13",
          "sourceid": "3"
        },
        {
          "pluginid": "10035",
          "alertRef": "10035",
          "alert": "Strict-Transport-Security Header Not Set",
          "name": "Strict-Transport-Security Header Not Set",
          "riskcode": "1",
          "confidence": "3",
          "riskdesc": "Low (High)",
          "desc": "<p>HTTP Strict Transport Security (HSTS) is a web security policy mechanism whereby a web server declares that complying user agents (such as a web browser) are to interact with it using only secure HTTPS connections (i.e. HTTP layered over TLS/SSL). HSTS is an IETF standards track protocol and is specified in RFC 6797.<\/p>",
          "instances": [
            {
              "uri": "https://prod-xIKciVAk.lab.practical-devsecops.training",
              "method": "GET"
            },
            {
              "uri": "https://prod-xIKciVAk.lab.practical-devsecops.training/sitemap.xml",
              "method": "GET"
            },
            {
              "uri": "https://prod-xIKciVAk.lab.practical-devsecops.training/robots.txt",
              "method": "GET"
            }
          ],
          "count": "3",
          "solution": "<p>Ensure that your web server, application server, load balancer, etc. is configured to enforce Strict-Transport-Security.<\/p>",
          "reference": "<p>https://cheatsheetseries.owasp.org/cheatsheets/HTTP_Strict_Transport_Security_Cheat_Sheet.html<\/p><p>https://owasp.org/www-community/Security_Headers<\/p><p>http://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security<\/p><p>http://caniuse.com/stricttransportsecurity<\/p><p>http://tools.ietf.org/html/rfc6797<\/p>",
          "cweid": "319",
          "wascid": "15",
          "sourceid": "3"
        },
        {
          "pluginid": "10021",
          "alertRef": "10021",
          "alert": "X-Content-Type-Options Header Missing",
          "name": "X-Content-Type-Options Header Missing",
          "riskcode": "1",
          "confidence": "2",
          "riskdesc": "Low (Medium)",
          "desc": "<p>The Anti-MIME-Sniffing header X-Content-Type-Options was not set to 'nosniff'. This allows older versions of Internet Explorer and Chrome to perform MIME-sniffing on the response body, potentially causing the response body to be interpreted and displayed as a content type other than the declared content type. Current (early 2014) and legacy versions of Firefox will use the declared content type (if one is set), rather than performing MIME-sniffing.<\/p>",
          "instances": [
            {
              "uri": "https://prod-xIKciVAk.lab.practical-devsecops.training",
              "method": "GET",
              "param": "X-Content-Type-Options"
            }
          ],
          "count": "1",
          "solution": "<p>Ensure that the application/web server sets the Content-Type header appropriately, and that it sets the X-Content-Type-Options header to 'nosniff' for all web pages.<\/p><p>If possible, ensure that the end user uses a standards-compliant and modern web browser that does not perform MIME-sniffing at all, or that can be directed by the web application/web server to not perform MIME-sniffing.<\/p>",
          "otherinfo": "<p>This issue still applies to error type pages (401, 403, 500, etc.) as those pages are often still affected by injection issues, in which case there is still concern for browsers sniffing pages away from their actual content type.<\/p><p>At \"High\" threshold this scan rule will not alert on client or server error responses.<\/p>",
          "reference": "<p>http://msdn.microsoft.com/en-us/library/ie/gg622941%28v=vs.85%29.aspx<\/p><p>https://owasp.org/www-community/Security_Headers<\/p>",
          "cweid": "693",
          "wascid": "15",
          "sourceid": "3"
        },
        {
          "pluginid": "10015",
          "alertRef": "10015",
          "alert": "Incomplete or No Cache-control Header Set",
          "name": "Incomplete or No Cache-control Header Set",
          "riskcode": "1",
          "confidence": "2",
          "riskdesc": "Low (Medium)",
          "desc": "<p>The cache-control header has not been set properly or is missing, allowing the browser and proxies to cache content.<\/p>",
          "instances": [
            {
              "uri": "https://prod-xIKciVAk.lab.practical-devsecops.training",
              "method": "GET",
              "param": "Cache-Control"
            }
          ],
          "count": "1",
          "solution": "<p>Whenever possible ensure the cache-control HTTP header is set with no-cache, no-store, must-revalidate.<\/p>",
          "reference": "<p>https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html#web-content-caching<\/p><p>https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control<\/p>",
          "cweid": "525",
          "wascid": "13",
          "sourceid": "3"
        },
        {
          "pluginid": "10017",
          "alertRef": "10017",
          "alert": "Cross-Domain JavaScript Source File Inclusion",
          "name": "Cross-Domain JavaScript Source File Inclusion",
          "riskcode": "1",
          "confidence": "2",
          "riskdesc": "Low (Medium)",
          "desc": "<p>The page includes one or more script files from a third-party domain.<\/p>",
          "instances": [
            {
              "uri": "https://prod-xIKciVAk.lab.practical-devsecops.training",
              "method": "GET",
              "param": "http://html5shim.googlecode.com/svn/trunk/html5.js",
              "evidence": "<script src=\"http://html5shim.googlecode.com/svn/trunk/html5.js\"><\/script>"
            }
          ],
          "count": "1",
          "solution": "<p>Ensure JavaScript source files are loaded from only trusted sources, and the sources can't be controlled by end users of the application.<\/p>",
          "reference": "<p><\/p>",
          "cweid": "829",
          "wascid": "15",
          "sourceid": "3"
        }
      ]
    },
    {
      "@name": "https://prod-xikcivak.lab.practical-devsecops.training",
      "@host": "prod-xikcivak.lab.practical-devsecops.training",
      "@port": "443",
      "@ssl": "true",
      "alerts": [
        {
          "pluginid": "10017",
          "alertRef": "10017",
          "alert": "Cross-Domain JavaScript Source File Inclusion",
          "name": "Cross-Domain JavaScript Source File Inclusion",
          "riskcode": "1",
          "confidence": "2",
          "riskdesc": "Low (Medium)",
          "desc": "<p>The page includes one or more script files from a third-party domain.<\/p>",
          "instances": [
            {
              "uri": "https://prod-xikcivak.lab.practical-devsecops.training/",
              "method": "GET",
              "param": "http://html5shim.googlecode.com/svn/trunk/html5.js",
              "evidence": "<script src=\"http://html5shim.googlecode.com/svn/trunk/html5.js\"><\/script>"
            }
          ],
          "count": "1",
          "solution": "<p>Ensure JavaScript source files are loaded from only trusted sources, and the sources can't be controlled by end users of the application.<\/p>",
          "reference": "<p><\/p>",
          "cweid": "829",
          "wascid": "15",
          "sourceid": "3"
        },
        {
          "pluginid": "10040",
          "alertRef": "10040",
          "alert": "Secure Pages Include Mixed Content (Including Scripts)",
          "name": "Secure Pages Include Mixed Content (Including Scripts)",
          "riskcode": "2",
          "confidence": "2",
          "riskdesc": "Medium (Medium)",
          "desc": "<p>The page includes mixed content, that is content accessed via HTTP instead of HTTPS.<\/p>",
          "instances": [
            {
              "uri": "https://prod-xikcivak.lab.practical-devsecops.training/",
              "method": "GET",
              "evidence": "http://html5shim.googlecode.com/svn/trunk/html5.js"
            }
          ],
          "count": "1",
          "solution": "<p>A page that is available over SSL/TLS must be comprised completely of content which is transmitted over SSL/TLS.<\/p><p>The page must not contain any content that is transmitted over unencrypted HTTP.<\/p><p> This includes content from third party sites.<\/p>",
          "otherinfo": "<p>tag=script src=http://html5shim.googlecode.com/svn/trunk/html5.js<\/p><p><\/p>",
          "reference": "<p>https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html<\/p>",
          "cweid": "311",
          "wascid": "4",
          "sourceid": "3"
        },
        {
          "pluginid": "10015",
          "alertRef": "10015",
          "alert": "Incomplete or No Cache-control Header Set",
          "name": "Incomplete or No Cache-control Header Set",
          "riskcode": "1",
          "confidence": "2",
          "riskdesc": "Low (Medium)",
          "desc": "<p>The cache-control header has not been set properly or is missing, allowing the browser and proxies to cache content.<\/p>",
          "instances": [
            {
              "uri": "https://prod-xikcivak.lab.practical-devsecops.training/",
              "method": "GET",
              "param": "Cache-Control"
            }
          ],
          "count": "1",
          "solution": "<p>Whenever possible ensure the cache-control HTTP header is set with no-cache, no-store, must-revalidate.<\/p>",
          "reference": "<p>https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html#web-content-caching<\/p><p>https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control<\/p>",
          "cweid": "525",
          "wascid": "13",
          "sourceid": "3"
        },
        {
          "pluginid": "10038",
          "alertRef": "10038",
          "alert": "Content Security Policy (CSP) Header Not Set",
          "name": "Content Security Policy (CSP) Header Not Set",
          "riskcode": "2",
          "confidence": "3",
          "riskdesc": "Medium (High)",
          "desc": "<p>Content Security Policy (CSP) is an added layer of security that helps to detect and mitigate certain types of attacks, including Cross Site Scripting (XSS) and data injection attacks. These attacks are used for everything from data theft to site defacement or distribution of malware. CSP provides a set of standard HTTP headers that allow website owners to declare approved sources of content that browsers should be allowed to load on that page — covered types are JavaScript, CSS, HTML frames, fonts, images and embeddable objects such as Java applets, ActiveX, audio and video files.<\/p>",
          "instances": [
            {
              "uri": "https://prod-xikcivak.lab.practical-devsecops.training/",
              "method": "GET"
            }
          ],
          "count": "1",
          "solution": "<p>Ensure that your web server, application server, load balancer, etc. is configured to set the Content-Security-Policy header, to achieve optimal browser support: \"Content-Security-Policy\" for Chrome 25+, Firefox 23+ and Safari 7+, \"X-Content-Security-Policy\" for Firefox 4.0+ and Internet Explorer 10+, and \"X-WebKit-CSP\" for Chrome 14+ and Safari 6+.<\/p>",
          "reference": "<p>https://developer.mozilla.org/en-US/docs/Web/Security/CSP/Introducing_Content_Security_Policy<\/p><p>https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html<\/p><p>http://www.w3.org/TR/CSP/<\/p><p>http://w3c.github.io/webappsec/specs/content-security-policy/csp-specification.dev.html<\/p><p>http://www.html5rocks.com/en/tutorials/security/content-security-policy/<\/p><p>http://caniuse.com/#feat=contentsecuritypolicy<\/p><p>http://content-security-policy.com/<\/p>",
          "cweid": "693",
          "wascid": "15",
          "sourceid": "3"
        },
        {
          "pluginid": "10035",
          "alertRef": "10035",
          "alert": "Strict-Transport-Security Header Not Set",
          "name": "Strict-Transport-Security Header Not Set",
          "riskcode": "1",
          "confidence": "3",
          "riskdesc": "Low (High)",
          "desc": "<p>HTTP Strict Transport Security (HSTS) is a web security policy mechanism whereby a web server declares that complying user agents (such as a web browser) are to interact with it using only secure HTTPS connections (i.e. HTTP layered over TLS/SSL). HSTS is an IETF standards track protocol and is specified in RFC 6797.<\/p>",
          "instances": [
            {
              "uri": "https://prod-xikcivak.lab.practical-devsecops.training/",
              "method": "GET"
            }
          ],
          "count": "1",
          "solution": "<p>Ensure that your web server, application server, load balancer, etc. is configured to enforce Strict-Transport-Security.<\/p>",
          "reference": "<p>https://cheatsheetseries.owasp.org/cheatsheets/HTTP_Strict_Transport_Security_Cheat_Sheet.html<\/p><p>https://owasp.org/www-community/Security_Headers<\/p><p>http://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security<\/p><p>http://caniuse.com/stricttransportsecurity<\/p><p>http://tools.ietf.org/html/rfc6797<\/p>",
          "cweid": "319",
          "wascid": "15",
          "sourceid": "3"
        },
        {
          "pluginid": "10021",
          "alertRef": "10021",
          "alert": "X-Content-Type-Options Header Missing",
          "name": "X-Content-Type-Options Header Missing",
          "riskcode": "1",
          "confidence": "2",
          "riskdesc": "Low (Medium)",
          "desc": "<p>The Anti-MIME-Sniffing header X-Content-Type-Options was not set to 'nosniff'. This allows older versions of Internet Explorer and Chrome to perform MIME-sniffing on the response body, potentially causing the response body to be interpreted and displayed as a content type other than the declared content type. Current (early 2014) and legacy versions of Firefox will use the declared content type (if one is set), rather than performing MIME-sniffing.<\/p>",
          "instances": [
            {
              "uri": "https://prod-xikcivak.lab.practical-devsecops.training/",
              "method": "GET",
              "param": "X-Content-Type-Options"
            }
          ],
          "count": "1",
          "solution": "<p>Ensure that the application/web server sets the Content-Type header appropriately, and that it sets the X-Content-Type-Options header to 'nosniff' for all web pages.<\/p><p>If possible, ensure that the end user uses a standards-compliant and modern web browser that does not perform MIME-sniffing at all, or that can be directed by the web application/web server to not perform MIME-sniffing.<\/p>",
          "otherinfo": "<p>This issue still applies to error type pages (401, 403, 500, etc.) as those pages are often still affected by injection issues, in which case there is still concern for browsers sniffing pages away from their actual content type.<\/p><p>At \"High\" threshold this scan rule will not alert on client or server error responses.<\/p>",
          "reference": "<p>http://msdn.microsoft.com/en-us/library/ie/gg622941%28v=vs.85%29.aspx<\/p><p>https://owasp.org/www-community/Security_Headers<\/p>",
          "cweid": "693",
          "wascid": "15",
          "sourceid": "3"
        },
        {
          "pluginid": "10036",
          "alertRef": "10036",
          "alert": "Server Leaks Version Information via \"Server\" HTTP Response Header Field",
          "name": "Server Leaks Version Information via \"Server\" HTTP Response Header Field",
          "riskcode": "1",
          "confidence": "3",
          "riskdesc": "Low (High)",
          "desc": "<p>The web/application server is leaking version information via the \"Server\" HTTP response header. Access to such information may facilitate attackers identifying other vulnerabilities your web/application server is subject to.<\/p>",
          "instances": [
            {
              "uri": "https://prod-xikcivak.lab.practical-devsecops.training/",
              "method": "GET",
              "evidence": "nginx/1.14.0 (Ubuntu)"
            }
          ],
          "count": "1",
          "solution": "<p>Ensure that your web server, application server, load balancer, etc. is configured to suppress the \"Server\" header or provide generic details.<\/p>",
          "reference": "<p>http://httpd.apache.org/docs/current/mod/core.html#servertokens<\/p><p>http://msdn.microsoft.com/en-us/library/ff648552.aspx#ht_urlscan_007<\/p><p>http://blogs.msdn.com/b/varunm/archive/2013/04/23/remove-unwanted-http-response-headers.aspx<\/p><p>http://www.troyhunt.com/2012/02/shhh-dont-let-your-response-headers.html<\/p>",
          "cweid": "200",
          "wascid": "13",
          "sourceid": "3"
        }
      ]
    }
  ]
}
```


> Please do not forget to share the answer (a screenshot and commands) with our staff via Slack Direct Message (DM).

> Hint: 
> 1. Explore the different features Dojo provides while keeping a note of URL changes in the address bar of your browser
> 2. Atleast visit, product page, engagement page and tests options in the Dojo portal
> 3. The 500 error while uploading ZAP’s output is because of the wrong arguments used. Please read the documentation of Dojo to resolve the error

## Automated Results Upload in GitLab

### Use script(s) to automatically push security findings to Vulnerability Management system from CI/CD

In this scenario, you will learn how to automatically manage security issues using vulnerability management systems like Defect Dojo.

> Once you click the **Start the Exercise** button, you will need to **wait 2 minutes** for the GitLab and Dojo machine to start.

> Remember!
>
>Except for DevSecOps-Box, every other machine **closes after two hours**, even if you are in the middle of the exercise
>
>After two hours, in case of a **404**, you need to refresh the exercise page and click on **Start the Exercise** button to continue working

### A simple CI/CD pipeline

Considering your DevOps team created a simple CI pipeline with the following contents.

```bash
image: docker:latest

services:
  - docker:dind

stages:
  - build
  - test
  - release
  - preprod
  - integration
  - prod

build:
  stage: build
  image: python:3.6
  before_script:
   - pip3 install --upgrade virtualenv
  script:
   - virtualenv env
   - source env/bin/activate
   - pip install -r requirements.txt
   - python manage.py check

test:
  stage: test
  image: python:3.6
  before_script:
   - pip3 install --upgrade virtualenv
  script:
   - virtualenv env
   - source env/bin/activate
   - pip install -r requirements.txt
   - python manage.py test taskManager

integration:
  stage: integration
  script:
    - echo "This is an integration step"

prod:
  stage: prod
  script:
    - echo "This is a deploy step."
```

We see four jobs in this pipeline, a **build** job, a **test** job, a **integration** job, and a **prod** job.

As a security engineer, I do not care what they are doing as part of these jobs. Why? Imagine having to learn every build/testing tool used by your DevOps team. It will be a nightmare! Instead, rely on the DevOps team for help.

Let’s log into GitLab using the following details and execute this pipeline.

Name	Value
**URL**	https://gitlab-ce-xIKciVAk.lab.practical-devsecops.training/root/django-nv/-/blob/master/.gitlab-ci.yml
**Username**	root
**Password**	pdso-training

Next, we need to create a CI/CD pipeline by replacing the **.gitlab-ci.yml** file content with the above CI script. Click on the **Edit** button to replace the content (use **Control+A** and **Control+V**).

Save changes to the file using the **Commit changes** button.

### Verify the pipeline run

As soon as a change is made to the repository, the pipeline starts executing the jobs.

We can see the results of this pipeline by visiting https://gitlab-ce-xIKciVAk.lab.practical-devsecops.training/root/django-nv/pipelines.

Click on the appropriate job name to see the output.

This exercise uses three machines behind the scenes, you already know about Gitlab CI. You will find details about the other two machines below.

Machine(s) access

Name	Value
**Dojo URL**	dojo-xIKciVAk.lab.practical-devsecops.training/
**Username**	root
**Password**	pdso-training

Name	Value
**Prod URL**	prod-xIKciVAk.lab.practical-devsecops.training
**Username**	admin
**Password**	admin

> You will use the prod machine in the next exercise (not the below one).

### Upload script

You can use the upload-results.py script from https://gitlab.practical-devsecops.training/-/snippets/3/raw

### Challenge

We will use the bandit tool to scan a repository for security issues and upload the tool’s output to DefectDojo in CI/CD pipeline.

1. Read the bandit documentation
2. Embed bandit in build stage and save the output as JSON file
3. Where should you upload the upload-results.py file for the fully automated pipeline to work?
4. Remember to follow all best practices while adding the baseline scan to CI/CD pipeline

Once you are done, please do not forget to share the pipeline script with our staff.

> Please try to do this exercise without looking at the solution on the next page.

Let’s move to the **next step**.

### Embed Bandit and upload script in CI/CD pipeline

> Remember!
>
>Except for DevSecOps-Box, every other machine **closes after two hours**, even if you are in the middle of the exercise
>
>After two hours, in case of a 404, you need to refresh the exercise page and click on **Start the Exercise** button to continue working

As discussed in the **Static Analysis using Bandit** exercise, we can embed the Bandit tool in our CI/CD pipeline. However, you need to run the command manually before you embed this SAST tool in the pipeline.

```bash
image: docker:latest

services:
  - docker:dind

stages:
  - build
  - test
  - release
  - preprod
  - integration
  - prod

build:
  stage: build
  image: python:3.6
  before_script:
   - pip3 install --upgrade virtualenv
  script:
   - virtualenv env
   - source env/bin/activate
   - pip install -r requirements.txt
   - python manage.py check

test:
  stage: test
  image: python:3.6
  before_script:
   - pip3 install --upgrade virtualenv
  script:
   - virtualenv env
   - source env/bin/activate
   - pip install -r requirements.txt
   - python manage.py test taskManager

sast:
  stage: build
  before_script:
    - apk add py-pip
  script:
    - docker pull hysnsec/bandit  # Download bandit docker container
    - docker run --user $(id -u):$(id -g) -v $(pwd):/src --rm hysnsec/bandit -r /src -f json -o /src/bandit-output.json
  after_script:
    - python3 upload-results.py --host $DOJO_HOST --api_key $DOJO_API_TOKEN --engagement_id 1 --product_id 1 --lead_id 1 --environment "Production" --result_file bandit-output.json --scanner "Bandit Scan"
  artifacts:
    paths: [bandit-output.json]
    when: always

integration:
  stage: integration
  script:
    - echo "This is an integration step"

prod:
  stage: prod
  script:
    - echo "This is a deploy step."
```

Before we commit this file to the repository, We need to set **DOJO_HOST** and **DOJO_API_TOKEN** under secrets variables by visiting the following URL

**Gitlab Variables URL**: https://gitlab-ce-xIKciVAk.lab.practical-devsecops.training/root/django-nv/-/settings/ci_cd

Name	Value
**Key**	DOJO_HOST
**Value**	dojo-xIKciVAk.lab.practical-devsecops.training

Name	Value
**Key**	DOJO_API_TOKEN
**Value**	Find it at https://dojo-xIKciVAk.lab.practical-devsecops.training/api/key-v2

You also need to log into the dojo website using the following credentials to fetch the API Key.

Name	Value
**Dojo URL**	dojo-xIKciVAk.lab.practical-devsecops.training/api/key-v2
**Username**	root
**Password**	pdso-training

Once you’re done with the variables, you can commit the **.gitlab-ci.yml** file and see the results of this pipeline by visiting https://gitlab-ce-xIKciVAk.lab.practical-devsecops.training/root/django-nv/pipelines.

Click on the appropriate job name to see the output.

The pipeline will fail because the job **sast** didn’t succeed. If you see the job’s output, you will realize that we didn’t upload the **upload-results**.py file into the repo and the CI system failed the build as it couldn’t find it in the repository.

Let’s move to the **next** page to add this script to the repository via the Git command line. Of course, we will perform these steps from DevSecOps Box.

### Upload python script in CI/CD pipeline

Before we can push the **upload-results.py** file to the repo, we need to set up the git command line.

### Initial git setup

To work with git repositories, we first need to set up a username and email. We can use git config commands to set it up.

```bash
git config --global user.email "student@pdevsecops.com"
git config --global user.name "student"
```

### Download/clone/copy the repository

We can use the **git clone** command to download the **django.nv** git repository to our local machine.

```bash
git clone http://root:pdso-training@gitlab-ce-xIKciVAk.lab.practical-devsecops.training/root/django-nv.git
```

> Notice the username/password combination before the at symbol?

By cloning the above repository, we created a local copy of the remote repository.

Lets **cd** into this repository to explore its content.

```bash
cd django-nv
```

### Add a file to the repository

First, lets download the **upload-results.py** script using the following curl command.

```bash
curl https://gitlab.practical-devsecops.training/-/snippets/3/raw -o upload-results.py
```

Add the file and push it to the django.nv repository.

```bash
git add upload-results.py
git commit -m "Add upload-results.py file"
```

### Push the changes to the repository

Since git is a decentralized source code management system, all changes live in your local git repository till you push them to the server. Think it like this **git** was meant to run even when you do not have internet connectivity, on flights, vessels or in a jungle somewhere__.

We have internet connectivity, lets push it to the remote git repository using the **git push** command.

```bash
git push origin master
Counting objects: 3, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 1.37 KiB | 1.37 MiB/s, done.
Total 3 (delta 1), reused 0 (delta 0)
To http://gitlab-ce-xIKciVAk.lab.practical-devsecops.training/root/django-nv.git
   577b30f..b0324c0  master -> master
```

As discussed earlier, any change to the repo kick starts the pipeline. We can see the result of this change in the pipeline tab of Gitlab CI at https://gitlab-ce-xIKciVAk.lab.practical-devsecops.training/root/django-nv/pipelines.

There you have it. Every time a developer makes a change, our SAST scanner will run and will automatically upload the results to the vulnerability management system.

You can verify the issues were uploaded successfully by visiting the [dojo website](https://dojo-xikcivak.lab.practical-devsecops.training/engagement/1).

Let’s move to the **next step**.

### Challenge: Upload ZAP results to Defect Dojo Automatically via CI/CD pipeline.

In this exercise, you will use the **upload-results.py** script to upload the ZAP scan results to the Defect Dojo in CI/CD pipeline.

1. Scan the production machine https://prod-xIKciVAk.lab.practical-devsecops.training with the help of the ZAP docker image
2. Store the ZAP scan results in a file and upload the security issues to Defect Dojo
3. Embed this upload script as part of the ZAP Scan in the CI/CD pipeline using after_script task

> Please do not forget to share the answer (a screenshot and the YML file) with our staff via Slack Direct Message (DM).

> Hint: https://defectdojo.readthedocs.io/en/latest/integrations.html

## Automated Results Upload in GitHub Actions

### Use script(s) to automatically push security findings to Vulnerability Management system from CI/CD

In this scenario, you will learn how to automatically manage security issues using vulnerability management systems like Defect Dojo.

> Note
>
>DevSecOps Box is an immutable machine, and hence it does not save the previous state after you close or reload the browser. The credentials that were entered or saved previously need to be provided again.

### A simple CI/CD pipeline

You’ve learned about CI/CD systems using GitLab and Jenkins. Both are good systems, but they also have different features, and use cases. We will look into another CI/CD system named **GitHub Actions** that debuted on **13 November 2019**. **GitHub Actions** is a CI/CD system that is built-in to GitHub with **free** and paid offerings.

Let’s get started!

### 1. Create a new repository

> If you haven’t registered for a GitHub account, please sign up for an account [here](https://github.com/join?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F&source=header-home)

First, we need to create a repository in our GitHub account by visiting https://github.com/new.

Create a repository named django.nv, you can also check the box with **Public** or **Private** options, and please ignore **Initialize this repository with** section for now.

Click the Create repository button.

### 2. Create a Personal Access Token (PAT)

Next, we will create and use PAT for git authentication in DevSecOps Box because GitHub will not support account passwords starting [August 2021](https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/).

Let’s create PAT by visiting https://github.com/settings/tokens,then click **Generate new token** button and give your token a name e.g. django.

Select repo option to access repositories from the command line, and scroll down to generate a new token.

> The token will have a format like this **ghp_xxxxxxxxx**.

Once you have the token, please copy and save it as a file in DevSecOps Box, so we can use the token whenever needed.

### 3. Initial git setup

To work with git repositories via Command Line Interface (CLI), aka terminal/command prompt, we need to set up a user and an email. We can use git config command to configure git user and email.

```bash
git config --global user.email "your_email@gmail.com"
git config --global user.name "your_username"
```

> You need to use your email and username, which are registered in GitHub.
>
> **Please don’t use your company’s GitHub credentials or token to practice these exercises**.

### 4. Download the repository

Let’s start by cloning **django.nv** in DevSecOps Box.

```bash
git clone https://gitlab.practical-devsecops.training/pdso/django.nv.git
```

By cloning the above repository, we created a local copy of the remote repository.

Let’s **cd** into this repository to explore its content.

```bash
cd django.nv
```

Since this repository was cloned from Gitlab, the remote URL of this Git repository is going to point to the GitLab URL. Let’s rename the repository’s Git URL to point to GitHub, enabling us to push our code to GitHub.

```bash
git remote rename origin old-origin
```

> In the command below, please change “username” with your GitHub username.

```bash
git remote add origin https://github.com/username/django.nv.git
```

Let’s check the status of our git repository.

```bash
git status
```

```
On branch master
Your branch is up to date with 'old-origin/master'.

nothing to commit, working tree clean
```

We are in the **master** branch and we need to create one more branch called **main** as a default branch.

```bash
git checkout -b main
```

> Why do we need a new branch? Because in this exercise we will use the main branch as a control to run the pipeline in every commit. If you don’t do this, you will not be able to see any pipeline in your repository.
>
>Read more about [Renaming the default branch from master](https://github.com/github/renaming).

Then, let’s push the code to the GitHub repository.

```bash
git push -u origin main
```

And enter your GitHub credentials when prompted (please use **Personal Access Token** as a password), then the code will be pushed to the GitHub repository.

### 5. Add a workflow file to the repository

To use **GitHub Actions**, you need to create **.github/workflows** directory and create a new YAML file named main.yaml or any other desired name because each file in the **.github/workflows** directory which has a **.yaml** extension will define a workflow.

Let’s create a simple workflow by entering the following commands in DevSecOps Box.

```bash
mkdir -p .github/workflows
```

```bash
cat >.github/workflows/main.yaml<<EOF
name: Django                                  # workflow name

on:
  push:
    branches:                                 # similar to "only" in GitLab
      - main

jobs:
  build:
    runs-on: ubuntu-latest                    # similar to "image" in GitLab
    steps:
      - uses: actions/checkout@v2

      - name: Setup python
        uses: actions/setup-python@v2
        with:
          python-version: '3.6'

      - run: |
          pip3 install --upgrade virtualenv
          virtualenv env
          source env/bin/activate
          pip install -r requirements.txt
          python manage.py check

  test:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - uses: actions/checkout@v2

      - name: Setup python
        uses: actions/setup-python@v2
        with:
          python-version: '3.6'

      - run: |
          pip3 install --upgrade virtualenv
          virtualenv env
          source env/bin/activate
          pip install -r requirements.txt
          python manage.py test taskManager

  integration:
    runs-on: ubuntu-latest
    needs: test
    steps:
      - run: echo "This is an integration step"
      - run: exit 1
        continue-on-error: true

  prod:
    runs-on: ubuntu-latest
    needs: integration
    steps:
      - run: echo "This is a deploy step."
EOF
```

> If you are not comfortable with the syntax, explore the GitHub Actions syntax athttps://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#about-yaml-syntax-for-workflows

Let’s add this file to the repository and commit the changes.

```bash
git add .github/workflows/main.yaml
git commit -m "Add github workflows"
```

### 6. Push the changes to the repository

Since git is a decentralized source code management system, all changes are made in your local git repository. You have to push these changes to the remote server for the committed changes to reflect on the remote git repository.

Let’s push the changes to the remote git repository using the **git push** command.

```bash
git push origin main
```

```
Counting objects: 5, done.
Delta compression using up to 16 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (5/5), 577 bytes | 577.00 KiB/s, done.
Total 5 (delta 1), reused 0 (delta 0)
remote: Resolving deltas: 100% (1/1), completed with 1 local object.
To https://github.com/username/django.nv.git
   df066a2..98e754f  main -> main
```

### 7. Verify the pipeline runs

Any change to the repo, will kick start the pipeline.

We can see the result of the pipeline by visiting our **django.nv** repository, clicking the **Actions** tab, and selecting the appropriate workflow name to see the output.

You will notice that the **integration** has **exit 1** and hence failed the job, but other jobs are still running. Why?

> You can find more details at https://docs.github.com/en/actions/learn-github-actions/introduction-to-github-actions#jobs.

#### Machine(s) access


Name	Value
**Dojo URL**	dojo-xIKciVAk.lab.practical-devsecops.training/
**Username**	root
**Password**	pdso-training

Name	Value
**Prod URL**	prod-xIKciVAk.lab.practical-devsecops.training
**Username**	admin
**Password**	admin

> You will use the prod machine in the next exercise (not the below one).

### Upload script

You can use the **upload-results.py** script from https://gitlab.practical-devsecops.training/-/snippets/3/raw

### Challenge

We will use the bandit tool to scan a repository for security issues and upload the tool’s output to DefectDojo in CI/CD pipeline.

1. Read the [bandit documentation](https://github.com/PyCQA/bandit/tree/master/bandit)
2. Embed bandit as **build** job and save the output as **JSON** file
3. Where should you upload the **upload-results.py** file for the fully automated pipeline to work?
4. Remember to follow all best practices while adding the baseline scan to CI/CD pipeline

Once you are done, please do not forget to share the pipeline script with our staff.

> Please try to do this exercise without looking at the solution on the next page.

Let’s move to the **next step**.

### Embed Bandit and upload script in GitHub Actions

As discussed in the **Static Analysis using Bandit** exercise, we can embed Bandit in our CI/CD pipeline. However, do remember you need to run the command manually before you embed this SAST tool in the pipeline.

Go back to the DevSecOps Box machine, and copy the below content to the **.github/workflows/main.yaml** file under **test** job.

```yml
  sast:
    runs-on: ubuntu-latest
    needs: test
    steps:
      - uses: actions/checkout@v2

      - run: docker run --rm -v $(pwd):/src hysnsec/bandit -r /src -f json -o /src/bandit-output.json

      - uses: actions/upload-artifact@v2
        with:
          name: Bandit
          path: bandit-output.json
        if: always()                        # what is this for?

      - uses: actions/setup-python@v2
        with:
          python-version: '3.6'

      - run: python3 upload-results.py --host $DOJO_HOST --api_key $DOJO_API_TOKEN --engagement_id 1 --product_id 1 --lead_id 1 --environment "Production" --result_file bandit-output.json --scanner "Bandit Scan"
```

> To understand **if: always()** Please refer to conditionals.

Before we commit this file to the repository, We need to set **DOJO_HOST** and **DOJO_API_TOKEN** using **secrets** in our repository. To set up a secret, go back to **django.nv** repository and click the **Settings** tab.

Click the **Secrets** option, then select **New repository secret** and add the following credentials into it.

Name	Value
**Key**	DOJO_HOST
**Value**	dojo-xIKciVAk.lab.practical-devsecops.training

Name	Value
**Key**	DOJO_API_TOKEN
**Value**	Find it at https://dojo-xIKciVAk.lab.practical-devsecops.training/api/key-v2

Once done, click the **Add secret** button.

You also need to log into the dojo website using the following credentials to fetch the API Key.

Name	Value
**Dojo URL**	dojo-xIKciVAk.lab.practical-devsecops.training/api/key-v2
**Username**	root
**Password**	pdso-training

Once you’re done with the variables, you can commit the **.github/workflows/main.yaml** file, and push the changes to GitHub.

Any change to the repo will kick start the pipeline.

We can see the result of the pipeline by visiting our **django.nv** repository, clicking the **Actions** tab, and selecting the appropriate workflow name to see the output.

The pipeline will fail because the job **sast** didn’t succeed. If you see the job’s output, you will realize that we didn’t upload the **upload-results.py** file into the repo and the CI system failed the build as it couldn’t find it in the repository.

Let’s move to the **next** page to add this script to the repository via the Git command line. Of course, we will perform these steps from DevSecOps Box.

### Upload python script in CI/CD pipeline

Lets download the **upload-results.py** script using the following curl command.

```bash
curl https://gitlab.practical-devsecops.training/-/snippets/3/raw -o upload-results.py
```

Add the file and push it to the django.nv repository.

```bash
git add upload-results.py
git commit -m "Add upload-results.py file"
```

### Push the changes to the repository

Since git is a decentralized source code management system, all changes live in your local **git** repository till you push them to the server. Think it like this git was meant to run even when you do not have internet connectivity, on flights, vessels or in a jungle somewhere__.

We have internet connectivity, lets push it to the remote git repository using the **git push** command.

```bash
git push origin main
```

```
Counting objects: 3, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 1.37 KiB | 1.37 MiB/s, done.
Total 3 (delta 1), reused 0 (delta 0)
To https://github.com/username/django.nv.git
   577b30f..b0324c0  main -> main
```

As discussed earlier, any change to the repo kick starts the pipeline. We can see the result of the pipeline by visiting our **django.nv** repository, clicking the **Actions** tab, and selecting the appropriate workflow name to see the output.

There you have it. Every time a developer makes a change, our SAST scanner will run and will automatically upload the results to the vulnerability management system.

You can verify the issues were uploaded successfully by visiting the [dojo website](https://dojo-xikcivak.lab.practical-devsecops.training/engagement/1).